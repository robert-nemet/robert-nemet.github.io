<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Learning eBPF: Maps, Ring Buffers and Output | DevCube</title>
<meta name=keywords content="ebpf,tutorial,linux,kernel"><meta name=description content="I set the stage for learning eBPF. As mentioned in the previous post, eBPF is a technology that allows us to run code in the kernel. This is a compelling technology, but it comes with a few limitations. One of them is that we can&rsquo;t use the standard output to print messages. At least not directly. Let&rsquo;s explore how we can do this.
Why can&rsquo;t I use the standard input/output? Let&rsquo;s look at this picture The eBPF programs are executed in the kernel."><meta name=author content="Robert Nemet"><link rel=canonical href=https://rnemet.dev/posts/ebpf/output-ebpf/><link crossorigin=anonymous href=/assets/css/stylesheet.9329d037bc79464b26647fb72e079cd738f5d2418b1df4da3b515db9e22cb4d9.css integrity="sha256-kynQN7x5RksmZH+3Lgec1zj10kGLHfTaO1FdueIstNk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://rnemet.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rnemet.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rnemet.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://rnemet.dev/apple-touch-icon.png><link rel=mask-icon href=https://rnemet.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-L148RQBR36"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-L148RQBR36",{anonymize_ip:!1})}</script><meta property="og:title" content="Learning eBPF: Maps, Ring Buffers and Output"><meta property="og:description" content="I set the stage for learning eBPF. As mentioned in the previous post, eBPF is a technology that allows us to run code in the kernel. This is a compelling technology, but it comes with a few limitations. One of them is that we can&rsquo;t use the standard output to print messages. At least not directly. Let&rsquo;s explore how we can do this.
Why can&rsquo;t I use the standard input/output? Let&rsquo;s look at this picture The eBPF programs are executed in the kernel."><meta property="og:type" content="article"><meta property="og:url" content="https://rnemet.dev/posts/ebpf/output-ebpf/"><meta property="og:image" content="https://rnemet.dev/images/ebpf_maps.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-10T12:53:57+02:00"><meta property="article:modified_time" content="2023-06-10T12:53:57+02:00"><meta property="og:site_name" content="DevCube"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rnemet.dev/images/ebpf_maps.jpg"><meta name=twitter:title content="Learning eBPF: Maps, Ring Buffers and Output"><meta name=twitter:description content="I set the stage for learning eBPF. As mentioned in the previous post, eBPF is a technology that allows us to run code in the kernel. This is a compelling technology, but it comes with a few limitations. One of them is that we can&rsquo;t use the standard output to print messages. At least not directly. Let&rsquo;s explore how we can do this.
Why can&rsquo;t I use the standard input/output? Let&rsquo;s look at this picture The eBPF programs are executed in the kernel."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rnemet.dev/posts/"},{"@type":"ListItem","position":2,"name":"Learning eBPF: Maps, Ring Buffers and Output","item":"https://rnemet.dev/posts/ebpf/output-ebpf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Learning eBPF: Maps, Ring Buffers and Output","name":"Learning eBPF: Maps, Ring Buffers and Output","description":"I set the stage for learning eBPF. As mentioned in the previous post, eBPF is a technology that allows us to run code in the kernel. This is a compelling technology, but it comes with a few limitations. One of them is that we can\u0026rsquo;t use the standard output to print messages. At least not directly. Let\u0026rsquo;s explore how we can do this.\nWhy can\u0026rsquo;t I use the standard input/output? Let\u0026rsquo;s look at this picture The eBPF programs are executed in the kernel.","keywords":["ebpf","tutorial","linux","kernel"],"articleBody":"I set the stage for learning eBPF. As mentioned in the previous post, eBPF is a technology that allows us to run code in the kernel. This is a compelling technology, but it comes with a few limitations. One of them is that we can’t use the standard output to print messages. At least not directly. Let’s explore how we can do this.\nWhy can’t I use the standard input/output? Let’s look at this picture The eBPF programs are executed in the kernel. The kernel is the core of the operating system. Other processes exist there that ensure the smooth operation of the system. To make this possible, the kernel is running in the privileged mode.\nPrograms run by the user are executed in the user space. The user space is running in the unprivileged mode. When the user space program wants to communicate with the kernel, it needs to use the system calls. The system calls are the interface between the user space and the kernel. The system calls are the only way to communicate with the kernel. The kernel is not exposing any other interface to the user space.\nBecause of that, we need to have the correct permissions for injecting, executing, and reading the eBPF programs. You must already notice that when you are running the simple hello.py script, you need to have root permissions. The root permissions have enough privileges to communicate with the kernel. In this case, load the eBPF program in the kernel, attach it to the events stream, and execute it.\nThis is an answer to why we can’t use the standard output directly. The standard output is a user space concept. But we can communicate with eBPF programs using the system data structures and calls. They are designed to allow communication between the user space and the kernel, and other eBPF programs can use them to exchange data. Let’s scratch the surface of this topic.\nSimple output(bpf_trace_printk) Let’s look at this BCC example:\n#!/usr/bin/python3 from bcc import BPF program = r\"\"\" #include int hello(void *ctx) { int pid = bpf_get_current_pid_tgid() \u003e\u003e 32; int uid = bpf_get_current_uid_gid() \u0026 0xFFFFFFFF; char command[TASK_COMM_LEN]; bpf_get_current_comm(command, sizeof(command)); bpf_trace_printk(\"uid = %d, pid = %d, comm %s\", uid, pid, command); return 0; } \"\"\" b = BPF(text=program, cflags=[\"-Wno-macro-redefined\"]) syscall = b.get_syscall_fnname(\"execve\") b.attach_kprobe(event=syscall, fn_name=\"hello\") b.trace_print() This simple program prints the uid, pid, and the command name of the process executing the execve system call. I use:\nThe bpf_get_current_pid_tgid function to get the pid(process id) of the process The bpf_get_current_uid_gid function to get the uid(user id) of the process The bpf_get_current_comm function to get the command name of the process The bpf_trace_printk is a function that allows us to print messages from the eBPF program. The messages are sent to the predefined pseudo-file on location /sys/kernel/debug/tracing/trace_pipe. So, bpf_trace_printk helper function sends my messages to the trace_pipe file. The trace_pipe file is a special file that is used by the kernel to send messages to the user space. Then I can read them with the trace_print() function or with the cat command.\nIn the above recording, you’ll notice whenever I execute the execve system call, the eBPF program prints the message on the top third of the screen. The messages are in the trace_pipe file, too. Notice the middle part of the screen where cat /sys/kernel/debug/tracing/trace_pipe is executed. At the bottom, I run simple commands like the regular user and root. Notice the difference in the messages. The messages that are printed by the root user have the uid 0. Also, notice that opening a new shell session create several message output. There are many messages because several actions are done when opening a new shell.\nWhile working bpf_trace_printk is easy, it has some limitations. For example, if you have multiple eBPF programs that are printing messages, all the messages will be mixed in the trace_pipe file. It is hard to distinguish which message is coming from which program. Also, the trace_pipe file is a special file designed for debugging purposes. It is not intended for production use. So, we must find a better way to communicate with the user space.\nI find it helpful to use bpf_trace_printk for debugging purposes. It is a quick way to print messages from the eBPF program.\nMaps Maps as data structures are used to store data. When it comes to eBPF, maps are data structures that are used to exchange data between the user space and the kernel. Also, maps are used to exchange data between eBPF programs. In general, maps are key-value stores. But still, different types of maps exist. The reason is that some of them are optimized for different use cases. At the same time, other eBPF maps hold information about specific object types. For example, there is the BPF_MAP_TYPE_QUEUE map, which is optimized as a FIFO(first in, first out) queue, and BPF_MAP_TYPE_STACK which provides a LIFO(last in, first out) stack. Check linux docs on them for more information.\nOr maps used to hold information about network devices.\nLet’s check this example:\n#!/usr/bin/python3 from bcc import BPF from time import sleep program = r\"\"\" struct data_t { u64 counter; int pid; char command[16]; }; BPF_HASH(counter_table, u64, struct data_t); int hello(void *ctx) { struct data_t zero = {}; struct data_t *val; u64 uid = bpf_get_current_uid_gid() \u0026 0xFFFFFFFF; int pid = bpf_get_current_pid_tgid() \u003e\u003e 32; val = counter_table.lookup_or_try_init(\u0026uid, \u0026zero); if (val) { val-\u003ecounter++; val-\u003epid = pid; bpf_get_current_comm(\u0026val-\u003ecommand, sizeof(val-\u003ecommand)); } return 0; } \"\"\" b = BPF(text=program, cflags=[\"-Wno-macro-redefined\"]) syscall = b.get_syscall_fnname(\"execve\") b.attach_kprobe(event=syscall, fn_name=\"hello\") old_s = \"\" while True: sleep(2) s = \"\" for k,v in b[\"counter_table\"].items(): s += f\"ID {k.value}: cnt: {v.counter} pid: {v.pid} comm: {v.command}\\t\" if s != old_s: print(s) old_s = s The above example is similar to the previous one. But this time, I’m using the map to store information about the processes. I use the BPF_HASH map to create the map counter_table. I use the uid of the process for a key, and for value, I use the struct data_t structure. The struct data_t structure holds the counter for all commands the user executed, pid, and the command name of the last process run by a user.\nThe hello function is attached to the execve system call. When the execve system call is executed, I check if the user is already in the map. If not, I add the user to the map. Suppose the user is already in the map. In that case, I increment the counter and update the pid and the command name of the last process executed by the user.\nLater, in Python script, I read the map and print the information about the users. I use the items() function to iterate over the map. The items() function returns the key and value for each entry in the map. I use the value to get the struct data_t structure. Then, I print the information about the user.\nRing buffers Like maps, ring buffers are data structures that exchange data between the user space and the kernel. Look at the picture:\nIn short, ring buffers are circular buffers. They have two pointers: one for reading and one for writing. The pointers are moving in the same direction. If the read pointer catches the write pointer, the buffer is empty. If the write pointer catches the read pointer, the buffer is full. Then, the next element to be written will be dropped.\nThere are two types of ring buffers BPF_PERF_OUTPUT and BPF_RINGBUF_OUTPUT. The BPF_RINGBUF_OUTPUT is more advanced than BPF_PERF_OUTPUT. I will not go into the details about the differences between them please check the docs.\nHere is a familiar example:\n#!/usr/bin/python3 from bcc import BPF program = r\"\"\" BPF_PERF_OUTPUT(counter_table); struct data_t { int pid; int uid; char command[16]; }; int hello(void *ctx) { struct data_t data = {}; data.pid = bpf_get_current_pid_tgid() \u003e\u003e 32; data.uid = bpf_get_current_uid_gid() \u0026 0xFFFFFFFF; bpf_get_current_comm(\u0026data.command, sizeof(data.command)); counter_table.perf_submit(ctx, \u0026data, sizeof(data)); return 0; } \"\"\" b = BPF(text=program, cflags=[\"-Wno-macro-redefined\"]) syscall = b.get_syscall_fnname(\"execve\") b.attach_kprobe(event=syscall, fn_name=\"hello\") def print_event(cpu, data, size): data = b[\"counter_table\"].event(data) print(f\"{data.pid} {data.uid} {data.command.decode()}\") b[\"counter_table\"].open_perf_buffer(print_event) while True: b.perf_buffer_poll() This time difference is when reading from the ring buffer, I’m passing the callback print_event. The print_event callback is called when the data is available in the ring buffer. It has to have three arguments: cpu, data, and size. The cpu argument is the cpu number on which the event was generated. The data argument is the data that is read from the ring buffer. The size argument is the size of the data read from the ring buffer.\nSummary So, even if eBPF has no direct access to the standard output, there are ways to exchange data between the user space and the kernel. Plus, given data structures, maps are usually optimized for the specific use case. That should make your life easier.\nReferences linux/bpf.h kernel docs: eBPF maps BCC reference guide: Maps BCC reference guide ","wordCount":"1478","inLanguage":"en","image":"https://rnemet.dev/images/ebpf_maps.jpg","datePublished":"2023-06-10T12:53:57+02:00","dateModified":"2023-06-10T12:53:57+02:00","author":{"@type":"Person","name":"Robert Nemet"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rnemet.dev/posts/ebpf/output-ebpf/"},"publisher":{"@type":"Organization","name":"DevCube","logo":{"@type":"ImageObject","url":"https://rnemet.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rnemet.dev/ accesskey=h title="Home (Alt + H)"><img src=https://rnemet.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rnemet.dev/posts/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://rnemet.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://rnemet.dev/posts/practical_k8s/ title="Practical k8s"><span>Practical k8s</span></a></li><li><a href=https://rnemet.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rnemet.dev/about/ title="About Me"><span>About Me</span></a></li><li><a href=https://rnemet.dev/ title><span></span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Learning eBPF: Maps, Ring Buffers and Output</h1><div class=post-description></div><div class=post-meta><span title='2023-06-10 12:53:57 +0200 CEST'>June 10, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Robert Nemet</div></header><figure class=entry-cover><img loading=lazy src=https://rnemet.dev/images/ebpf_maps.jpg alt><p></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-cant-i-use-the-standard-inputoutput aria-label="Why can&amp;rsquo;t I use the standard input/output?">Why can&rsquo;t I use the standard input/output?</a></li><li><a href=#simple-outputbpf_trace_printk aria-label="Simple output(bpf_trace_printk)">Simple output(bpf_trace_printk)</a></li><li><a href=#maps aria-label=Maps>Maps</a></li><li><a href=#ring-buffers aria-label="Ring buffers">Ring buffers</a></li><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>I set the stage for learning <a href=https://rnemet.dev/posts/ebpf/learn-ebpf>eBPF</a>. As mentioned in the previous post, eBPF is a technology that allows us to run code in the kernel.
This is a compelling technology, but it comes with a few limitations. One of them is that we can&rsquo;t use the standard output to print messages. At least not directly. Let&rsquo;s explore how we can do this.</p><h2 id=why-cant-i-use-the-standard-inputoutput>Why can&rsquo;t I use the standard input/output?<a hidden class=anchor aria-hidden=true href=#why-cant-i-use-the-standard-inputoutput>#</a></h2><p>Let&rsquo;s look at this picture <img loading=lazy src=/images/eBPF-short-overview.jpg alt=ebpf-workflow></p><p>The eBPF programs are executed in the kernel. The kernel is the core of the operating system. Other processes exist there that ensure the smooth operation of the
system. To make this possible, the kernel is running in the privileged mode.</p><p>Programs run by the user are executed in the user space. The user space is running in the unprivileged mode. When the user space program wants to communicate with the
kernel, it needs to use the system calls. The system calls are the interface between the user space and the kernel. The system calls are the only way to communicate with
the kernel. The kernel is not exposing any other interface to the user space.</p><p>Because of that, we need to have the correct permissions for injecting, executing, and reading the eBPF programs. You must already notice that when you are running the
simple <a href=https://github.com/robert-nemet/learn-ebpf/blob/main/intro/hello.py>hello.py</a> script, you need to have root permissions. The root permissions have enough privileges
to communicate with the kernel. In this case, load the eBPF program in the kernel, attach it to the events stream, and execute it.</p><p>This is an answer to why we can&rsquo;t use the standard output directly. The standard output is a user space concept. But we can communicate with eBPF programs using the system data structures and calls. They are designed to allow communication between the user space and the kernel, and other eBPF programs can use them to exchange data. Let&rsquo;s scratch the surface of this topic.</p><h2 id=simple-outputbpf_trace_printk>Simple output(bpf_trace_printk)<a hidden class=anchor aria-hidden=true href=#simple-outputbpf_trace_printk>#</a></h2><p>Let&rsquo;s look at this BCC example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> bcc <span style=color:#f92672>import</span> BPF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program <span style=color:#f92672>=</span> <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>#include &lt;linux/sched.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>int hello(void *ctx) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    int uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    char command[TASK_COMM_LEN];
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    bpf_get_current_comm(command, sizeof(command));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    bpf_trace_printk(&#34;uid = </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>, pid = </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>, comm </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;, uid, pid, command);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    return 0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> BPF(text<span style=color:#f92672>=</span>program, cflags<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;-Wno-macro-redefined&#34;</span>])
</span></span><span style=display:flex><span>syscall <span style=color:#f92672>=</span> b<span style=color:#f92672>.</span>get_syscall_fnname(<span style=color:#e6db74>&#34;execve&#34;</span>)
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>attach_kprobe(event<span style=color:#f92672>=</span>syscall, fn_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>trace_print()
</span></span></code></pre></div><p>This simple program prints the uid, pid, and the command name of the process executing the <code>execve</code> system call. I use:</p><ul><li>The <a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#4-bpf_get_current_pid_tgid>bpf_get_current_pid_tgid</a> function to get the pid(process id) of the
process</li><li>The <a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#5-bpf_get_current_uid_gid>bpf_get_current_uid_gid</a> function to get the uid(user id) of the
process</li><li>The <a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#6-bpf_get_current_comm>bpf_get_current_comm</a> function to get the command name of the process</li></ul><p>The <a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#1-bpf_trace_printk>bpf_trace_printk</a> is a function that allows us to print messages from the
eBPF program. The messages are sent to the predefined pseudo-file on location <code>/sys/kernel/debug/tracing/trace_pipe</code>. So, <code>bpf_trace_printk</code> helper function sends my
messages to the <code>trace_pipe</code> file. The <code>trace_pipe</code> file is a special file that is used by the kernel to send messages to the user space. Then I can read them with the
<code>trace_print()</code> function or with the <code>cat</code> command.</p><div id=bpf_trace_printk></div><script src=https://rnemet.dev//js/asciinema-player.min.js></script><link rel=stylesheet type=text/css href=https://rnemet.dev//css/asciinema-player.css><script>AsciinemaPlayer.create("/casts/bpf_trace_printk.cast",document.getElementById("bpf_trace_printk"),{autoPlay:"true"})</script><p>In the above recording, you&rsquo;ll notice whenever I execute the <code>execve</code> system call, the eBPF program prints the message on the top third of the screen. The messages are
in the <code>trace_pipe</code> file, too. Notice the middle part of the screen where <code>cat /sys/kernel/debug/tracing/trace_pipe</code> is executed. At the bottom, I run simple commands
like the regular user and root. Notice the difference in the messages. The messages that are printed by the root user have the uid 0. Also, notice that opening a new shell
session create several message output. There are many messages because several actions are done when opening a new shell.</p><p>While working <code>bpf_trace_printk</code> is easy, it has some limitations. For example, if you have multiple eBPF programs that are printing messages, all the messages will be
mixed in the <code>trace_pipe</code> file. It is hard to distinguish which message is coming from which program. Also, the <code>trace_pipe</code> file is a special file
designed for debugging purposes. It is not intended for production use. So, we must find a better way to communicate with the user space.</p><p>I find it helpful to use <code>bpf_trace_printk</code> for debugging purposes. It is a quick way to print messages from the eBPF program.</p><h2 id=maps>Maps<a hidden class=anchor aria-hidden=true href=#maps>#</a></h2><p>Maps as data structures are used to store data. When it comes to eBPF, maps are data structures that are used to exchange data between the user space and the kernel.
Also, maps are used to exchange data between eBPF programs. In general, maps are key-value stores. But still, different types of maps exist. The reason is that
some of them are optimized for different use cases. At the same time, other eBPF maps hold information about specific object types. For example, there is the <code>BPF_MAP_TYPE_QUEUE</code> map, which is optimized as a FIFO(first in, first out) queue, and <code>BPF_MAP_TYPE_STACK</code> which provides a LIFO(last in, first out) stack. Check <a href=https://docs.kernel.org/bpf/map_queue_stack.html>linux docs</a>
on them for more information.</p><p>Or maps used to hold information about <a href=https://docs.kernel.org/bpf/map_devmap.html>network devices</a>.</p><p>Let&rsquo;s check this example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/python3  </span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> bcc <span style=color:#f92672>import</span> BPF
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> time <span style=color:#f92672>import</span> sleep
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program <span style=color:#f92672>=</span> <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>struct data_t {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   u64 counter;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   int pid;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   char command[16];
</span></span></span><span style=display:flex><span><span style=color:#e6db74>};
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>BPF_HASH(counter_table, u64, struct data_t);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>int hello(void *ctx) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   struct data_t zero = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   struct data_t *val;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   u64 uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   val = counter_table.lookup_or_try_init(&amp;uid, &amp;zero);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   if (val) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      val-&gt;counter++;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      val-&gt;pid = pid;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      bpf_get_current_comm(&amp;val-&gt;command, sizeof(val-&gt;command));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   return 0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> BPF(text<span style=color:#f92672>=</span>program, cflags<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;-Wno-macro-redefined&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>syscall <span style=color:#f92672>=</span> b<span style=color:#f92672>.</span>get_syscall_fnname(<span style=color:#e6db74>&#34;execve&#34;</span>)
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>attach_kprobe(event<span style=color:#f92672>=</span>syscall, fn_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>old_s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>   sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>   s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> k,v <span style=color:#f92672>in</span> b[<span style=color:#e6db74>&#34;counter_table&#34;</span>]<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>      s <span style=color:#f92672>+=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;ID </span><span style=color:#e6db74>{</span>k<span style=color:#f92672>.</span>value<span style=color:#e6db74>}</span><span style=color:#e6db74>: cnt: </span><span style=color:#e6db74>{</span>v<span style=color:#f92672>.</span>counter<span style=color:#e6db74>}</span><span style=color:#e6db74> pid: </span><span style=color:#e6db74>{</span>v<span style=color:#f92672>.</span>pid<span style=color:#e6db74>}</span><span style=color:#e6db74> comm: </span><span style=color:#e6db74>{</span>v<span style=color:#f92672>.</span>command<span style=color:#e6db74>}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> s <span style=color:#f92672>!=</span> old_s:
</span></span><span style=display:flex><span>      print(s)
</span></span><span style=display:flex><span>   old_s <span style=color:#f92672>=</span> s
</span></span></code></pre></div><p>The above example is similar to the previous one. But this time, I&rsquo;m using the map to store information about the processes. I use the <code>BPF_HASH</code> map to create the map
<code>counter_table</code>. I use the uid of the process for a key, and for value, I use the <code>struct data_t</code> structure. The <code>struct data_t</code> structure holds the counter for all
commands the user executed, pid, and the command name of the last process run by a user.</p><p>The <code>hello</code> function is attached to the <code>execve</code> system call. When the <code>execve</code> system call is executed, I check if the user is already in the map. If not, I add
the user to the map. Suppose the user is already in the map. In that case, I increment the counter and update the pid and the command name of the last process executed by the user.</p><p>Later, in Python script, I read the map and print the information about the users. I use the <code>items()</code> function to iterate over the map. The <code>items()</code> function returns
the key and value for each entry in the map. I use the <code>value</code> to get the <code>struct data_t</code> structure. Then, I print the information about the user.</p><div id=bpf_hello_map></div><script src=https://rnemet.dev//js/asciinema-player.min.js></script><link rel=stylesheet type=text/css href=https://rnemet.dev//css/asciinema-player.css><script>AsciinemaPlayer.create("/casts/bpf_hello_map.cast",document.getElementById("bpf_hello_map"),{autoPlay:"true"})</script><h2 id=ring-buffers>Ring buffers<a hidden class=anchor aria-hidden=true href=#ring-buffers>#</a></h2><p>Like maps, ring buffers are data structures that exchange data between the user space and the kernel. Look at the picture:</p><p><img loading=lazy src=/images/ring_buffer.png alt=ring-buffer></p><p>In short, ring buffers are circular buffers. They have two pointers: one for reading and one for writing. The pointers are moving in the same direction. If the read
pointer catches the write pointer, the buffer is empty. If the write pointer catches the read pointer, the buffer is full. Then, the next element to be written will be dropped.</p><p>There are two types of ring buffers <a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#2-bpf_perf_output>BPF_PERF_OUTPUT</a> and
<a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#5-bpf_ringbuf_output>BPF_RINGBUF_OUTPUT</a>. The <code>BPF_RINGBUF_OUTPUT</code> is more advanced than <code>BPF_PERF_OUTPUT</code>.
I will not go into the details about the differences between them <a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#5-bpf_ringbuf_output>please check the docs</a>.</p><p>Here is a familiar example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/python3  </span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> bcc <span style=color:#f92672>import</span> BPF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program <span style=color:#f92672>=</span> <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>BPF_PERF_OUTPUT(counter_table); 
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>struct data_t {     
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   int pid;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   int uid;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   char command[16];
</span></span></span><span style=display:flex><span><span style=color:#e6db74>};
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>int hello(void *ctx) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   struct data_t data = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>; 
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   data.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   data.uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   bpf_get_current_comm(&amp;data.command, sizeof(data.command));
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   counter_table.perf_submit(ctx, &amp;data, sizeof(data)); 
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>   return 0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> BPF(text<span style=color:#f92672>=</span>program, cflags<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;-Wno-macro-redefined&#34;</span>]) 
</span></span><span style=display:flex><span>syscall <span style=color:#f92672>=</span> b<span style=color:#f92672>.</span>get_syscall_fnname(<span style=color:#e6db74>&#34;execve&#34;</span>)
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>attach_kprobe(event<span style=color:#f92672>=</span>syscall, fn_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_event</span>(cpu, data, size):  
</span></span><span style=display:flex><span>   data <span style=color:#f92672>=</span> b[<span style=color:#e6db74>&#34;counter_table&#34;</span>]<span style=color:#f92672>.</span>event(data)
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>data<span style=color:#f92672>.</span>pid<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>data<span style=color:#f92672>.</span>uid<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>data<span style=color:#f92672>.</span>command<span style=color:#f92672>.</span>decode()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>b[<span style=color:#e6db74>&#34;counter_table&#34;</span>]<span style=color:#f92672>.</span>open_perf_buffer(print_event) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:   
</span></span><span style=display:flex><span>   b<span style=color:#f92672>.</span>perf_buffer_poll()
</span></span></code></pre></div><p>This time difference is when reading from the ring buffer, I&rsquo;m passing the callback <code>print_event</code>. The <code>print_event</code> callback is called when the data is available in
the ring buffer. It has to have three arguments: <code>cpu</code>, <code>data</code>, and <code>size</code>. The <code>cpu</code> argument is the cpu number on which the event was generated. The <code>data</code> argument
is the data that is read from the ring buffer. The <code>size</code> argument is the size of the data read from the ring buffer.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>So, even if eBPF has no direct access to the standard output, there are ways to exchange data between the user space and the kernel. Plus, given data structures,
maps are usually optimized for the specific use case. That should make your life easier.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://elixir.bootlin.com/linux/v6.4.3/source/include/uapi/linux/bpf.h#L905>linux/bpf.h</a></li><li><a href=https://docs.kernel.org/bpf/maps.html>kernel docs: eBPF maps</a></li><li><a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#maps>BCC reference guide: Maps</a></li><li><a href=https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md>BCC reference guide</a></li></ul><div class=subscribe><iframe src=https://rnemet.substack.com/embed width=480 height=320 style="border:1px solid #eee;background:#fff;margin:auto;display:block" frameborder=0 scrolling=no></iframe></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://rnemet.dev/tags/ebpf/>ebpf</a></li><li><a href=https://rnemet.dev/tags/tutorial/>tutorial</a></li><li><a href=https://rnemet.dev/tags/linux/>linux</a></li><li><a href=https://rnemet.dev/tags/kernel/>kernel</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on x" href="https://x.com/intent/tweet/?text=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output&amp;url=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f&amp;hashtags=ebpf%2ctutorial%2clinux%2ckernel"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f&amp;title=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output&amp;summary=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output&amp;source=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f&title=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on whatsapp" href="https://api.whatsapp.com/send?text=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output%20-%20https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on telegram" href="https://telegram.me/share/url?text=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output&amp;url=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Learning eBPF: Maps, Ring Buffers and Output on ycombinator" href="https://news.ycombinator.com/submitlink?t=Learning%20eBPF%3a%20Maps%2c%20Ring%20Buffers%20and%20Output&u=https%3a%2f%2frnemet.dev%2fposts%2febpf%2foutput-ebpf%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://rnemet.dev/>DevCube</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>