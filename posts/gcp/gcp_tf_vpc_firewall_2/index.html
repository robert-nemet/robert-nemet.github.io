<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exploring GCP With Terraform: VPC Firewall Rules, part 2 | DevCube</title>
<meta name=keywords content="gcp,terraform,cloud,networking,vpc,firewall"><meta name=description content="GCP Networking with Terraform, part 2: Firewall"><meta name=author content="Robert Nemet"><link rel=canonical href=https://rnemet.dev/posts/gcp/gcp_tf_vpc_firewall_2/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://rnemet.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rnemet.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rnemet.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://rnemet.dev/apple-touch-icon.png><link rel=mask-icon href=https://rnemet.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rnemet.dev/posts/gcp/gcp_tf_vpc_firewall_2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-L148RQBR36"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-L148RQBR36")}</script><meta property="og:url" content="https://rnemet.dev/posts/gcp/gcp_tf_vpc_firewall_2/"><meta property="og:site_name" content="DevCube"><meta property="og:title" content="Exploring GCP With Terraform: VPC Firewall Rules, part 2"><meta property="og:description" content="GCP Networking with Terraform, part 2: Firewall"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-28T21:48:19+02:00"><meta property="article:modified_time" content="2023-08-28T21:48:19+02:00"><meta property="article:tag" content="Gcp"><meta property="article:tag" content="Terraform"><meta property="article:tag" content="Cloud"><meta property="article:tag" content="Networking"><meta property="article:tag" content="Vpc"><meta property="article:tag" content="Firewall"><meta property="og:image" content="https://rnemet.dev/images/gcp-tf-start3.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rnemet.dev/images/gcp-tf-start3.png"><meta name=twitter:title content="Exploring GCP With Terraform: VPC Firewall Rules, part 2"><meta name=twitter:description content="GCP Networking with Terraform, part 2: Firewall"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rnemet.dev/posts/"},{"@type":"ListItem","position":2,"name":"Exploring GCP With Terraform: VPC Firewall Rules, part 2","item":"https://rnemet.dev/posts/gcp/gcp_tf_vpc_firewall_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Exploring GCP With Terraform: VPC Firewall Rules, part 2","name":"Exploring GCP With Terraform: VPC Firewall Rules, part 2","description":"GCP Networking with Terraform, part 2: Firewall","keywords":["gcp","terraform","cloud","networking","vpc","firewall"],"articleBody":"This post would be 3rd part of the series about exploring GCP with Terraform. In the previous part, I created VPC networks, subnets, and a few firewall rules. In this part, I will explore more firewall rules and their parameters.\nMore precisely, I’ll set up three VPCs: back-office, services and storage. In VPC back_office, I’ll have two subnets; in others, I’ll have one subnet. For the sake of conversation, imagine that VMs in the back-office have to call VMs in services and storage. Also, direct access to VMs from outside should not be allowed, except for one that will serve for maintenance.\nWhat I have done so far I have two VPCs: back-office and services. The VPC back-office has a subnet back-office and the VPC services a subnet named services. In each VPC, I added firewall rules to allow SSH access from outside through IAP. I also added a firewall rule to allow ICMP traffic from anywhere. Each VPC has a VM instance.\nThe Terraform project is growing. If you look at how I set a base workflow in the first post of this series, now I have two more similar workflows for networks and vms. It is not the best practice to have it like this, but this will be addressed later.\nVPC Firewall rules So, what is a firewall rule? A firewall rule is a set of conditions that define what traffic is allowed to enter or leave a VPC network. A collection of parameters defines each firewall rule. Those parameters are:\ndirection - ingress or egress (default: ingress) priority - the priority of the rule. The lower the number, the higher the priority. The default value is 1000. action - allow or deny enforced - if the rule is enforced. The default value is true. target - the target of the rule. The target can be a tag, a service account, or a network. source - the source of the traffic. The source can be a tag, a service account, or a network. protocol - the protocol of the traffic. The protocols like TCP, UDP, ICMP, etc. logs - boolean. Make logs to see if the rule is matched or not. Setting up the stage VPC back_office has two subnets: back-office and back-office-private. So far, I have firewall rules: back-office-iap, back-office-icmp, and back-office-ssh, allowing ingress traffic from Google IAP, ICMP from anywhere, and SSH from anywhere. So, adding a new subnet back-office-private to the VPC back-office:\n# subnet for back office: private resource \"google_compute_subnetwork\" \"back_office_private\" { name = \"back-office-private\" ip_cidr_range = \"10.2.0.0/24\" network = google_compute_network.back_office.self_link region = var.region } To create a VM, you can use this code as a template inside the vms workflow:\nresource \"google_compute_instance\" \"services_vm_test\" { name = \"services-vm-test\" machine_type = \"f1-micro\" zone = var.zone scheduling { preemptible = true automatic_restart = false provisioning_model = \"SPOT\" } boot_disk { initialize_params { image = \"debian-cloud/debian-11\" } } network_interface { network = data.terraform_remote_state.network.outputs.vpc_services.id subnetwork = data.terraform_remote_state.network.outputs.vpc_services_subnetwork.id } } You may wonder what is this part:\nnetwork_interface { network = data.terraform_remote_state.network.outputs.vpc_services.id subnetwork = data.terraform_remote_state.network.outputs.vpc_services_subnetwork.id } Where is that defined? Since I have a network creation in the different workflow networks, I need to get the network ID and subnet ID from that workflow. I can do that by using the terraform_remote_state data source. But first, I need to export it in the networks workflow in the outputs.tf file:\noutput \"vpc_services\" { value = google_compute_network.services } output \"vpc_services_subnetwork\" { value = google_compute_subnetwork.services } Using the template above for VM and exposing all VPCs and subnets from networks, I can add two VMs in each subnet. The VMs in the back-office subnet will be named back-office-vm1 and back-office-vm2. The VMs in the back-office-private subnet will be named back-office-private-vm1 and back-office-private-vm2. First, I must change the networks and then the vms. Then, I can look for created instances:\n$ gcloud compute instances list NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUS back-office-private-vm1 us-central1-c f1-micro true 10.2.0.3 RUNNING back-office-private-vm2 us-central1-c f1-micro true 10.2.0.2 RUNNING back-office-vm1 us-central1-c f1-micro true 10.1.0.9 RUNNING back-office-vm2 us-central1-c f1-micro true 10.1.0.10 RUNNING services-vm-test us-central1-c f1-micro true 10.1.0.5 RUNNING Then, let’s try to connect to any VM from the local machine:\n$ gcloud compute ssh back-office-vm1 --zone us-central1-c --tunnel-through-iap Then, from it, let’s try to connect to any other VM, ping it:\n$ ping -c 5 10.2.0.3 PING 10.2.0.3 (10.2.0.3) 56(84) bytes of data. 64 bytes from 10.2.0.3: icmp_seq=1 ttl=64 time=0.884 ms 64 bytes from 10.2.0.3: icmp_seq=2 ttl=64 time=0.165 ms 64 bytes from 10.2.0.3: icmp_seq=3 ttl=64 time=0.233 ms 64 bytes from 10.2.0.3: icmp_seq=4 ttl=64 time=0.159 ms 64 bytes from 10.2.0.3: icmp_seq=5 ttl=64 time=0.238 ms --- 10.2.0.3 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4103ms rtt min/avg/max/mdev = 0.159/0.335/0.884/0.276 ms Yes, you can connect to any VM inside VPC. Why? Because we have a firewall rule that allows ICMP traffic from anywhere. Let’s delete that rule and try again(from the local machine):\n$ gcloud compute firewall-rules delete back-office-icmp The following firewalls will be deleted: - [back-office-icmp] Do you want to continue (Y/n)? y Deleted [https://www.googleapis.com/compute/v1/projects/network-playground-382512/global/firewalls/back-office-icmp]. Repeat the ping command from the connected VM to any other VM:\nping -c 5 10.2.0.3 PING 10.2.0.3 (10.2.0.3) 56(84) bytes of data. --- 10.2.0.3 ping statistics --- 5 packets transmitted, 0 received, 100% packet loss, time 4074ms Now, at this moment VMs, can not communicate with each other.\nTightening access: Only one VM for SSH (bastion) Let’s say we want to allow SSH access only to one VM from outside. We can do that by adding a firewall rule that allows SSH access only to one VM. Let’s remove the rule back-office-ssh as it is not practical. Why? I’m accessing VMs with the tunnel through IAP, so I do not need it. It would be helpful only if I could access them directly. That means that the target VM has an external IP. But I do not want that.\nAnd let’s modify the rule back-office-iap to allow SSH access only to one VM. Let’s add the tag bastion to the VM:\nresource \"google_compute_firewall\" \"back_office_iap\" { name = \"back-office-iap\" network = google_compute_network.back_office.self_link source_ranges = [\"35.235.240.0/20\"] target_tags = [\"bastion\"] direction = \"INGRESS\" allow { protocol = \"tcp\" } } I am using the tag bastion to allow SSH access by applying this firewall rule only to VMs with particular tags. If I try to access the VM back-office-vm1 from the local machine, I will get an error:\n$ gcloud compute ssh back-office-vm1 --zone us-central1-c --tunnel-through-iap ERROR: (gcloud.compute.start-iap-tunnel) Error while connecting [4003: 'failed to connect to backend']. (Failed to connect to port 22) kex_exchange_identification: Connection closed by remote host Connection closed by UNKNOWN port 65535 Recommendation: To check for possible causes of SSH connectivity issues and get recommendations, rerun the ssh command with the --troubleshoot option. gcloud compute ssh back-office-vm1 --project=network-playground-382512 --zone=us-central1-c --troubleshoot Or, to investigate an IAP tunneling issue: gcloud compute ssh back-office-vm1 --project=network-playground-382512 --zone=us-central1-c --troubleshoot --tunnel-through-iap ERROR: (gcloud.compute.ssh) [/usr/bin/ssh] exited with return code [255]. Let’s add the tag bastion to the VM back-office-vm1:\n$ gcloud compute instances add-tags back-office-vm1 --zone=us-central1-c --tags=bastion Updated [https://www.googleapis.com/compute/v1/projects/network-playground-382512/zones/us-central1-c/instances/back-office-vm1]. Now, connecting to the VM back-office-vm1 works. But connecting to any other VM in the VPC back-office doesn’t work. Why? Because we have a firewall rule that allows SSH access only to the VM back-office-vm1. The firewall matches the target with the tag value. If I tag any other VM in the VPC back-office with the tag bastion, I can connect to it.\nWell, I’m not happy that adding/removing tags is so easy. I want a more secure way to allow SSH access to VMs. I could use the service account to enable SSH access:\nresource \"google_service_account\" \"back_office_fw_sa\" { account_id = \"back-office\" display_name = \"back-office\" } resource \"google_compute_firewall\" \"back_office_iap\" { name = \"back-office-iap\" network = google_compute_network.back_office.self_link source_ranges = [\"35.235.240.0/20\"] target_service_accounts = [google_service_account.back_office_fw_sa.email] direction = \"INGRESS\" allow { protocol = \"tcp\" } depends_on = [google_service_account.back_office_fw_sa] } Connecting to the VM back-office-vm1 from the local machine, I will get the same error. Why? Because I’m not using the service account to connect to the VM. I’m using the tunnel through IAP. Let’s add the service account to the VM back-office-vm1:\nresource \"google_compute_instance\" \"back_office_vm1\" { name = \"back-office-vm1\" ... allow_stopping_for_update = true service_account { email = data.terraform_remote_state.network.outputs.back_office_fw_sa scopes = [\"https://www.googleapis.com/auth/cloud-platform\"] } ... } I added the service account to the VM back-office-vm1. Now, I can connect to it from the local machine. IAP can connect to it. Anyone who passes the IAP authentication can connect to it. But I can’t connect to any other VM in the VPC back-office. Why? Because I’m not using the service account to connect to the VMs. I’m using the tunnel through IAP, and the firewall rule allows access only to the back-office-vm1 VM.\nThe scopes are required to allow the service account to access the resources. When adding service accounts to VMs, you must set allow_stopping_for_update = true and service account scopes. Changing the service account on the VM requires stopping the VM.\nThis requirement makes a difference. You can add and remove tags on the fly but can’t do that with service accounts. You must stop the VM to change the service account. That is why using service accounts is more secure than using tags.\nNotice that I exported the service account email from the networks workflow. I did that because I needed to use it in the vms workflow.\nOK, now I can connect to the VM back-office-vm1, in the VPC back-office, from the local machine via the IAP tunnel. But I can connect to any other VM in the VPC back-office. But I still can connect to all other VMs in the VPC services and storages. I’ll remove the IAP firewall rule for those VPCs to fix this. But then I’ll need access from the VPC’s back_office VMs to the VPC’s services and storages VMs. Keep the ICMP rule for VPC services and storages.\nYou can do it now if you did not add VPC storages, a subnet, and VMs. Just remember to add VPC and subnet to the networks workflow and VMs to the vms workflow. For the storage subnet in the VPC storage, I used CIDR 10.120.0.0/24. And just for a reminder, CIDR for subnet services in VPC services is 10.1.0.0/24, and subnet back-office in VPC back_office is 10.1.0.0/24 and subnet back-office-private in VPC back_office is 10.2.0.0/24.\nTightening access: Accessing other VPCs OK, now what? I can’t connect to any VM in the VPC services and datastorages from the local machine because I just removed IAP firewall rules for those VPCs. I can connect only to back-office_vm1 from the local machine. But from it, I can connect to any other VM in the VPC back-office, but not in other VPCs. To be able to connect from the local machine to back-office-vm1 and then to any VMs in VPC services and storages, I need first to connect the VPC back-office to VPC services and storages. I can do that by setting up VPC peering. I’ll set up VPC peering between VPC back-office and services and between VPC back-office and storages:\nresource \"google_compute_network_peering\" \"back_office_service_peering\" { name = \"back-office-services-peering\" network = google_compute_network.back_office.self_link peer_network = google_compute_network.services.self_link } resource \"google_compute_network_peering\" \"service_back_office_peering\" { name = \"services-back-office-peering\" network = google_compute_network.services.self_link peer_network = google_compute_network.back_office.self_link } resource \"google_compute_network_peering\" \"back_office_datastorage_peering\" { name = \"back-office-storage-peering\" network = google_compute_network.back_office.self_link peer_network = google_compute_network.storage.self_link } resource \"google_compute_network_peering\" \"datastorage_back_office_peering\" { name = \"storage-back-office-peering\" network = google_compute_network.storage.self_link peer_network = google_compute_network.back_office.self_link } But we’ll get an error when applying the changes:\nError: Error waiting for Adding Network Peering: An IP range in the peer network (10.1.0.0/24) overlaps with an IP range in the local network (10.1.0.0/24) allocated by resource (projects/network-playground-382512/regions/us-central1/subnetworks/back-office). Why? Because the VPC back-office and services have subnets with the same IP range. When setting up VPC peering, it is essential to know that the IP ranges of the subnets must not overlap. Changing the IP ranges of subnets in VPC services is OK. But this means we need to plan the IP ranges of subnets. If you are using IPv6 in a VPC, then you don’t need to worry about this. But, if you are using IPv4, you need to plan the IP ranges of subnets. The reason is that if you want to change CIDR for a subnet, you need to free all resources that use this subnet first, like deleting all VMs.\nChanging the IP ranges of subnets in VPC services is easy. I’ll change the subnet services IP range to 10.3.0.0/24. But to do that, I need to delete the VMs in the VPC services and recreate peering between VPCs. So, I’ll remove VMs from the VPC services_. Then, fixing the subnet range in VPC services, recreate peering between VPCs. And finally, adding back deleted VMs to the VPC services.\nWhile I’m doing this, I’ll revert SSH access to the VMs in all VPCs, but this time, I’ll use CIDR ranges to allow access:\nresource \"google_compute_firewall\" \"services_ssh\" { name = \"services-ssh\" network = google_compute_network.services.self_link source_ranges = [\"10.1.0.0/24\", \"10.2.0.0/24\"] direction = \"INGRESS\" allow { protocol = \"tcp\" ports = [\"22\"] } } This limits access to the VMs in the VPC services from the VPC back-office and back-office-private subnets. I’ll do the same for the VPC storage.\nYou can add one for the VPC storage as well. On top of all this, you’ll need to add public SSH keys to the VMs. You can do it per VM or project. I’ll do it on the project level for now:\nresource \"google_compute_project_metadata\" \"default\" { metadata = { ssh-keys = \u003c\u003cEOF user:ssh-rsa public_key_goes_here user EOF } } When adding SSH public keys to the project level, you are allowing SSH access to all VMs in the project. For now, this is good enough. To generate SSH keys, you can use the command ssh-keygen:\n$ ssh-keygen -f private-key -C rnemet -b 2048 Generating public/private rsa key pair. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in private-key Your public key has been saved in private-key.pub ... The code above will generate two files: private-key and private-key.pub. The file private-key is the private key, and the file private-key.pub is the public key. Now, you can use the public key to add it to the project metadata. You can also use the private key to connect to the VMs. That means you must keep the private key safe and be on machines you use to connect to the VMs. After adding the public key to the project metadata, you can connect to the VMs in the VPC services and storages from VPC back-office VMs. All you need when connecting to the VMs is the private key on bastion VMs:\n$ gcloud compute scp ./private-key rnemet@back-office-vm1:.ssh/private-key --zone=us-central1-c External IP address was not found; defaulting to using IAP tunneling. WARNING: To increase the performance of the tunnel, consider installing NumPy. For instructions, please see https://cloud.google.com/iap/docs/using-tcp-forwarding#increasing_the_tcp_upload_bandwidth private-key When connecting to the VMs:\n$ ssh rnemet@10.120.0.3 -i .ssh/private-key With this setup, I can connect to the VMs in the VPC services and storages from the VM in the VPC back-office. Direct access to other VMs is not possible because of IAP and firewall rules.\nConclusion So far, I have created VPCs, subnets, and VMs. I have also created firewall rules to allow SSH access to the VMs from one VM inside my networks. I have also created VPC peering between VPCs. Also, I started to share resources between Terraform state files. However, my TF project is growing and needs a better structure. I need to invest some time to improve it. But at the same time, I would like to put some services that are reachable from the outside.\nWhat do you think? What would you do next? Let me know…\nReferences GCP Firewall GCP TF firewall GCP TF instances GCP scopes GCP VPC peering ","wordCount":"2631","inLanguage":"en","image":"https://rnemet.dev/images/gcp-tf-start3.png","datePublished":"2023-08-28T21:48:19+02:00","dateModified":"2023-08-28T21:48:19+02:00","author":{"@type":"Person","name":"Robert Nemet"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rnemet.dev/posts/gcp/gcp_tf_vpc_firewall_2/"},"publisher":{"@type":"Organization","name":"DevCube","logo":{"@type":"ImageObject","url":"https://rnemet.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rnemet.dev/ accesskey=h title="Home (Alt + H)"><img src=https://rnemet.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rnemet.dev/posts/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://rnemet.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://rnemet.dev/posts/practical_k8s/ title="Practical k8s"><span>Practical k8s</span></a></li><li><a href=https://rnemet.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rnemet.dev/about/ title="About Me"><span>About Me</span></a></li><li><a href=https://rnemet.dev/ title><span></span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Exploring GCP With Terraform: VPC Firewall Rules, part 2</h1><div class=post-description>GCP Networking with Terraform, part 2: Firewall</div><div class=post-meta><span title='2023-08-28 21:48:19 +0200 CEST'>August 28, 2023</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Robert Nemet</div></header><figure class=entry-cover><img loading=lazy src=https://rnemet.dev/images/gcp-tf-start3.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-i-have-done-so-far aria-label="What I have done so far">What I have done so far</a></li><li><a href=#vpc-firewall-rules aria-label="VPC Firewall rules">VPC Firewall rules</a><ul><li><a href=#setting-up-the-stage aria-label="Setting up the stage">Setting up the stage</a><ul><li><a href=#tightening-access-only-one-vm-for-ssh-bastion aria-label="Tightening access: Only one VM for SSH (bastion)">Tightening access: Only one VM for SSH (bastion)</a></li><li><a href=#tightening-access-accessing-other-vpcs aria-label="Tightening access: Accessing other VPCs">Tightening access: Accessing other VPCs</a></li></ul></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>This post would be 3rd part of the series about exploring GCP with Terraform. In the <a href=/posts/gcp/gcp_tf_vpc>previous part</a>, I created VPC networks, subnets, and a few
firewall rules. In this part, I will explore more firewall rules and their parameters.</p><p>More precisely, I&rsquo;ll set up three VPCs: <em>back-office</em>, <em>services</em> and <em>storage</em>. In VPC <em>back_office</em>, I&rsquo;ll have two subnets; in others, I&rsquo;ll have one subnet. For the
sake of conversation, imagine that VMs in the <em>back-office</em> have to call VMs in <em>services</em> and <em>storage</em>. Also, direct access to VMs from outside should not be
allowed, except for one that will serve for maintenance.</p><h2 id=what-i-have-done-so-far>What I have done so far<a hidden class=anchor aria-hidden=true href=#what-i-have-done-so-far>#</a></h2><p>I have two VPCs: <em>back-office</em> and <em>services</em>. The VPC <em>back-office</em> has a subnet <em>back-office</em> and the VPC <em>services</em> a subnet named <em>services</em>. In each VPC, I added firewall rules to allow SSH access from outside through IAP. I also added a firewall rule to allow ICMP traffic from anywhere. Each VPC has a VM instance.</p><p>The Terraform project is growing. If you look at how I set a <code>base</code> workflow in <a href=/posts/gcp/start_with_gcp/#setting-up-the-project>the first post of this series</a>, now I have two more similar workflows for <code>networks</code> and <code>vms</code>. It is not the best practice to have it like this, but this will be addressed later.</p><h2 id=vpc-firewall-rules>VPC Firewall rules<a hidden class=anchor aria-hidden=true href=#vpc-firewall-rules>#</a></h2><p>So, what is a firewall rule? A firewall rule is a set of conditions that define what traffic is allowed to enter or leave a VPC network. A collection of parameters defines each firewall rule. Those parameters are:</p><ul><li>direction - ingress or egress (default: ingress)</li><li>priority - the priority of the rule. The lower the number, the higher the priority. The default value is 1000.</li><li>action - allow or deny</li><li>enforced - if the rule is enforced. The default value is true.</li><li>target - the target of the rule. The target can be a tag, a service account, or a network.</li><li>source - the source of the traffic. The source can be a tag, a service account, or a network.</li><li>protocol - the protocol of the traffic. The protocols like TCP, UDP, ICMP, etc.</li><li>logs - boolean. Make logs to see if the rule is matched or not.</li></ul><h3 id=setting-up-the-stage>Setting up the stage<a hidden class=anchor aria-hidden=true href=#setting-up-the-stage>#</a></h3><p>VPC <em>back_office</em> has two subnets: <em>back-office</em> and <em>back-office-private</em>. So far, I have firewall rules: <code>back-office-iap</code>, <code>back-office-icmp</code>, and
<code>back-office-ssh</code>, allowing ingress traffic from Google IAP, ICMP from anywhere, and SSH from anywhere. So, adding a new subnet <em>back-office-private</em> to the VPC
<em>back-office</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#75715e># subnet for back office: private 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_subnetwork&#34; &#34;back_office_private&#34;</span> {
</span></span><span style=display:flex><span>  name          <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office-private&#34;</span>
</span></span><span style=display:flex><span>  ip_cidr_range <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;10.2.0.0/24&#34;</span>
</span></span><span style=display:flex><span>  network       <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>  region        <span style=color:#f92672>=</span> <span style=color:#66d9ef>var</span>.<span style=color:#66d9ef>region</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To create a VM, you can use this code as a template inside the <code>vms</code> workflow:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_instance&#34; &#34;services_vm_test&#34;</span> {
</span></span><span style=display:flex><span>  name         <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;services-vm-test&#34;</span>
</span></span><span style=display:flex><span>  machine_type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;f1-micro&#34;</span>
</span></span><span style=display:flex><span>  zone         <span style=color:#f92672>=</span> <span style=color:#66d9ef>var</span>.<span style=color:#66d9ef>zone</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>scheduling</span> {
</span></span><span style=display:flex><span>    preemptible        <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    automatic_restart  <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    provisioning_model <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SPOT&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>boot_disk</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>initialize_params</span> {
</span></span><span style=display:flex><span>      image <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debian-cloud/debian-11&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>network_interface</span> {
</span></span><span style=display:flex><span>    network    <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>terraform_remote_state</span>.<span style=color:#66d9ef>network</span>.<span style=color:#66d9ef>outputs</span>.<span style=color:#66d9ef>vpc_services</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>    subnetwork <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>terraform_remote_state</span>.<span style=color:#66d9ef>network</span>.<span style=color:#66d9ef>outputs</span>.<span style=color:#66d9ef>vpc_services_subnetwork</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You may wonder what is this part:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>network_interface</span> {
</span></span><span style=display:flex><span>    network    <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>terraform_remote_state</span>.<span style=color:#66d9ef>network</span>.<span style=color:#66d9ef>outputs</span>.<span style=color:#66d9ef>vpc_services</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>    subnetwork <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>terraform_remote_state</span>.<span style=color:#66d9ef>network</span>.<span style=color:#66d9ef>outputs</span>.<span style=color:#66d9ef>vpc_services_subnetwork</span>.<span style=color:#66d9ef>id</span>
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>Where is that defined? Since I have a network creation in the different workflow <code>networks</code>, I need to get the network ID and subnet ID from that workflow. I can
do that by using the <code>terraform_remote_state</code> data source. But first, I need to export it in the <code>networks</code> workflow in the <code>outputs.tf</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>output</span> <span style=color:#e6db74>&#34;vpc_services&#34;</span> {
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>services</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>output</span> <span style=color:#e6db74>&#34;vpc_services_subnetwork&#34;</span> {
</span></span><span style=display:flex><span>  value <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_subnetwork</span>.<span style=color:#66d9ef>services</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using the template above for VM and exposing all VPCs and subnets from <code>networks</code>, I can add two VMs in each subnet. The VMs in the <em>back-office</em> subnet will be named
<em>back-office-vm1</em> and <em>back-office-vm2</em>. The VMs in the <em>back-office-private</em> subnet will be named <em>back-office-private-vm1</em> and <em>back-office-private-vm2</em>. First, I
must change the <code>networks</code> and then the <code>vms</code>. Then, I can look for created instances:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcloud compute instances list
</span></span><span style=display:flex><span>NAME                     ZONE           MACHINE_TYPE  PREEMPTIBLE  INTERNAL_IP  EXTERNAL_IP  STATUS
</span></span><span style=display:flex><span>back-office-private-vm1  us-central1-c  f1-micro      true         10.2.0.3                  RUNNING
</span></span><span style=display:flex><span>back-office-private-vm2  us-central1-c  f1-micro      true         10.2.0.2                  RUNNING
</span></span><span style=display:flex><span>back-office-vm1          us-central1-c  f1-micro      true         10.1.0.9                  RUNNING
</span></span><span style=display:flex><span>back-office-vm2          us-central1-c  f1-micro      true         10.1.0.10                 RUNNING
</span></span><span style=display:flex><span>services-vm-test         us-central1-c  f1-micro      true         10.1.0.5                  RUNNING
</span></span></code></pre></div><p>Then, let&rsquo;s try to connect to any VM from the local machine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcloud compute ssh back-office-vm1 --zone us-central1-c --tunnel-through-iap
</span></span></code></pre></div><p>Then, from it, let&rsquo;s try to connect to any other VM, ping it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ping -c <span style=color:#ae81ff>5</span> 10.2.0.3
</span></span><span style=display:flex><span>PING 10.2.0.3 <span style=color:#f92672>(</span>10.2.0.3<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.2.0.3: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.884 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.2.0.3: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.165 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.2.0.3: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.233 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.2.0.3: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.159 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.2.0.3: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.238 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.2.0.3 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> packets transmitted, <span style=color:#ae81ff>5</span> received, 0% packet loss, time 4103ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.159/0.335/0.884/0.276 ms
</span></span></code></pre></div><p>Yes, you can connect to any VM inside VPC. Why? Because we have a firewall rule that allows ICMP traffic from anywhere. Let&rsquo;s delete that rule and try again(from the
local machine):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcloud compute firewall-rules delete back-office-icmp
</span></span><span style=display:flex><span>The following firewalls will be deleted:
</span></span><span style=display:flex><span> - <span style=color:#f92672>[</span>back-office-icmp<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Do you want to <span style=color:#66d9ef>continue</span> <span style=color:#f92672>(</span>Y/n<span style=color:#f92672>)</span>?  y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deleted <span style=color:#f92672>[</span>https://www.googleapis.com/compute/v1/projects/network-playground-382512/global/firewalls/back-office-icmp<span style=color:#f92672>]</span>.
</span></span></code></pre></div><p>Repeat the ping command from the connected VM to any other VM:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ping -c <span style=color:#ae81ff>5</span> 10.2.0.3
</span></span><span style=display:flex><span>PING 10.2.0.3 <span style=color:#f92672>(</span>10.2.0.3<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.2.0.3 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> packets transmitted, <span style=color:#ae81ff>0</span> received, 100% packet loss, time 4074ms
</span></span></code></pre></div><p>Now, at this moment VMs, can not communicate with each other.</p><h4 id=tightening-access-only-one-vm-for-ssh-bastion>Tightening access: Only one VM for SSH (bastion)<a hidden class=anchor aria-hidden=true href=#tightening-access-only-one-vm-for-ssh-bastion>#</a></h4><p>Let&rsquo;s say we want to allow SSH access only to one VM from outside. We can do that by adding a firewall rule that allows SSH access only to
one VM. Let&rsquo;s remove the rule <em>back-office-ssh</em> as it is not practical. Why? I&rsquo;m accessing VMs with the tunnel through IAP, so I do not need
it. It would be helpful only if I could access them directly. That means that the target VM has an external IP. But I do not want that.</p><p>And let&rsquo;s modify the rule <em>back-office-iap</em> to allow SSH access only to one VM. Let&rsquo;s add the tag <em>bastion</em> to the VM:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_firewall&#34; &#34;back_office_iap&#34;</span> {
</span></span><span style=display:flex><span>  name    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office-iap&#34;</span>
</span></span><span style=display:flex><span>  network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  source_ranges <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;35.235.240.0/20&#34;</span>]
</span></span><span style=display:flex><span>  target_tags   <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;bastion&#34;</span>]
</span></span><span style=display:flex><span>  direction     <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INGRESS&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>allow</span> {
</span></span><span style=display:flex><span>    protocol <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tcp&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I am using the tag <em>bastion</em> to allow SSH access by applying this firewall rule only to VMs with particular tags. If I try to access the
VM <em>back-office-vm1</em> from the local machine, I will get an error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcloud compute ssh back-office-vm1 --zone us-central1-c --tunnel-through-iap
</span></span><span style=display:flex><span>ERROR: <span style=color:#f92672>(</span>gcloud.compute.start-iap-tunnel<span style=color:#f92672>)</span> Error <span style=color:#66d9ef>while</span> connecting <span style=color:#f92672>[</span>4003: <span style=color:#e6db74>&#39;failed to connect to backend&#39;</span><span style=color:#f92672>]</span>. <span style=color:#f92672>(</span>Failed to connect to port 22<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>kex_exchange_identification: Connection closed by remote host
</span></span><span style=display:flex><span>Connection closed by UNKNOWN port <span style=color:#ae81ff>65535</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Recommendation: To check <span style=color:#66d9ef>for</span> possible causes of SSH connectivity issues and get
</span></span><span style=display:flex><span>recommendations, rerun the ssh command with the --troubleshoot option.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gcloud compute ssh back-office-vm1 --project<span style=color:#f92672>=</span>network-playground-382512 --zone<span style=color:#f92672>=</span>us-central1-c --troubleshoot
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Or, to investigate an IAP tunneling issue:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gcloud compute ssh back-office-vm1 --project<span style=color:#f92672>=</span>network-playground-382512 --zone<span style=color:#f92672>=</span>us-central1-c --troubleshoot --tunnel-through-iap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ERROR: <span style=color:#f92672>(</span>gcloud.compute.ssh<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>/usr/bin/ssh<span style=color:#f92672>]</span> exited with <span style=color:#66d9ef>return</span> code <span style=color:#f92672>[</span>255<span style=color:#f92672>]</span>.
</span></span></code></pre></div><p>Let&rsquo;s add the tag <em>bastion</em> to the VM <em>back-office-vm1</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ gcloud compute instances add-tags back-office-vm1 --zone<span style=color:#f92672>=</span>us-central1-c --tags<span style=color:#f92672>=</span>bastion
</span></span><span style=display:flex><span>Updated <span style=color:#f92672>[</span>https://www.googleapis.com/compute/v1/projects/network-playground-382512/zones/us-central1-c/instances/back-office-vm1<span style=color:#f92672>]</span>.
</span></span></code></pre></div><p>Now, connecting to the VM <em>back-office-vm1</em> works. But connecting to any other VM in the VPC <em>back-office</em> doesn&rsquo;t work. Why? Because we have
a firewall rule that allows SSH access only to the VM <em>back-office-vm1</em>. The firewall matches the target with the tag value. If I tag any
other VM in the VPC <em>back-office</em> with the tag <em>bastion</em>, I can connect to it.</p><p>Well, I&rsquo;m not happy that adding/removing tags is so easy. I want a more secure way to allow SSH access to VMs. I could use the service
account to enable SSH access:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_service_account&#34; &#34;back_office_fw_sa&#34;</span> {
</span></span><span style=display:flex><span>  account_id   <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office&#34;</span>
</span></span><span style=display:flex><span>  display_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_firewall&#34; &#34;back_office_iap&#34;</span> {
</span></span><span style=display:flex><span>  name    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office-iap&#34;</span>
</span></span><span style=display:flex><span>  network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  source_ranges           <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;35.235.240.0/20&#34;</span>]
</span></span><span style=display:flex><span>  target_service_accounts <span style=color:#f92672>=</span> [<span style=color:#66d9ef>google_service_account</span>.<span style=color:#66d9ef>back_office_fw_sa</span>.<span style=color:#66d9ef>email</span>]
</span></span><span style=display:flex><span>  direction               <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INGRESS&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>allow</span> {
</span></span><span style=display:flex><span>    protocol <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tcp&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  depends_on <span style=color:#f92672>=</span> [<span style=color:#66d9ef>google_service_account</span>.<span style=color:#66d9ef>back_office_fw_sa</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Connecting to the VM <em>back-office-vm1</em> from the local machine, I will get the same error. Why? Because I&rsquo;m not using the
service account to connect to the VM. I&rsquo;m using the tunnel through IAP. Let&rsquo;s add the service account to the VM <em>back-office-vm1</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_instance&#34; &#34;back_office_vm1&#34;</span> {
</span></span><span style=display:flex><span>  name         <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office-vm1&#34;</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  allow_stopping_for_update <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>service_account</span> {
</span></span><span style=display:flex><span>    email  <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>terraform_remote_state</span>.<span style=color:#66d9ef>network</span>.<span style=color:#66d9ef>outputs</span>.<span style=color:#66d9ef>back_office_fw_sa</span>
</span></span><span style=display:flex><span>    scopes <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;https://www.googleapis.com/auth/cloud-platform&#34;</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I added the service account to the VM <em>back-office-vm1</em>. Now, I can connect to it from the local machine. IAP can connect to it. Anyone who passes the IAP
authentication can connect to it. But I can&rsquo;t connect to any other VM in the VPC <em>back-office</em>. Why? Because I&rsquo;m not using the service account to connect
to the VMs. I&rsquo;m using the tunnel through IAP, and the firewall rule allows access only to the <em>back-office-vm1</em> VM.</p><p>The scopes are required to allow the service account to access the resources. When adding service accounts to VMs, you must set <code>allow_stopping_for_update = true</code> and service account scopes. Changing the service account on the VM requires stopping the VM.</p><p>This requirement makes a difference. You can add and remove tags on the fly but can&rsquo;t do that with service accounts. You must stop the VM to change the service account. That is why using service accounts is more secure than using tags.</p><p>Notice that I exported the service account email from the <code>networks</code> workflow. I did that because I needed to use it in the <code>vms</code> workflow.</p><p>OK, now I can connect to the VM <em>back-office-vm1</em>, in the VPC <em>back-office</em>, from the local machine via the IAP tunnel. But I can connect to any other VM in the VPC
<em>back-office</em>. But I still can connect to all other VMs in the VPC <em>services</em> and <em>storages</em>. I&rsquo;ll remove the IAP firewall rule for those VPCs to fix this. But then
I&rsquo;ll need access from the VPC&rsquo;s <em>back_office</em> VMs to the VPC&rsquo;s <em>services</em> and <em>storages</em> VMs. Keep the ICMP rule for VPC <em>services</em> and <em>storages</em>.</p><p>You can do it now if you did not add VPC <em>storages</em>, a subnet, and VMs. Just remember to add VPC and subnet to the <code>networks</code> workflow and VMs to the <code>vms</code>
workflow. For the <em>storage</em> subnet in the VPC <em>storage</em>, I used CIDR <code>10.120.0.0/24</code>. And just for a reminder, CIDR for subnet <em>services</em> in VPC <em>services</em> is
<code>10.1.0.0/24</code>, and subnet <em>back-office</em> in VPC <em>back_office</em> is <code>10.1.0.0/24</code> and subnet <em>back-office-private</em> in VPC <em>back_office</em> is <code>10.2.0.0/24</code>.</p><h4 id=tightening-access-accessing-other-vpcs>Tightening access: Accessing other VPCs<a hidden class=anchor aria-hidden=true href=#tightening-access-accessing-other-vpcs>#</a></h4><p>OK, now what? I can&rsquo;t connect to any VM in the VPC <em>services</em> and <em>datastorages</em> from the local machine because I just removed IAP firewall rules for those VPCs.
I can connect only to <em>back-office_vm1</em> from the local machine. But from it, I can connect to any other VM in the VPC <em>back-office</em>, but not in other VPCs.
To be able to connect from the local machine to <em>back-office-vm1</em> and then to any VMs in VPC <em>services</em> and <em>storages</em>, I need first to connect the VPC <em>back-office</em>
to VPC <em>services</em> and <em>storages</em>. I can do that by setting up VPC peering. I&rsquo;ll set up VPC peering between VPC <em>back-office</em> and <em>services</em> and between VPC
<em>back-office</em> and <em>storages</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_network_peering&#34; &#34;back_office_service_peering&#34;</span> {
</span></span><span style=display:flex><span>  name         <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office-services-peering&#34;</span>
</span></span><span style=display:flex><span>  network      <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>  peer_network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>services</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_network_peering&#34; &#34;service_back_office_peering&#34;</span> {
</span></span><span style=display:flex><span>  name         <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;services-back-office-peering&#34;</span>
</span></span><span style=display:flex><span>  network      <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>services</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>  peer_network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_network_peering&#34; &#34;back_office_datastorage_peering&#34;</span> {
</span></span><span style=display:flex><span>  name         <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;back-office-storage-peering&#34;</span>
</span></span><span style=display:flex><span>  network      <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>  peer_network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>storage</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_network_peering&#34; &#34;datastorage_back_office_peering&#34;</span> {
</span></span><span style=display:flex><span>  name         <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;storage-back-office-peering&#34;</span>
</span></span><span style=display:flex><span>  network      <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>storage</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>  peer_network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>back_office</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But we&rsquo;ll get an error when applying the changes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Error: Error waiting for Adding Network Peering: An IP range in the peer network (10.1.0.0/24) overlaps with an IP range in the local network (10.1.0.0/24) allocated by 
</span></span><span style=display:flex><span> resource (projects/network-playground-382512/regions/us-central1/subnetworks/back-office).
</span></span></code></pre></div><p>Why? Because the VPC <em>back-office</em> and <em>services</em> have subnets with the same IP range. When setting up VPC peering, it is essential to know that the IP ranges of the
subnets must not overlap. Changing the IP ranges of subnets in VPC <em>services</em> is OK. But this means we need to plan the IP ranges of subnets. If you are using
IPv6 in a VPC, then you don&rsquo;t need to worry about this. But, if you are using IPv4, you need to plan the IP ranges of subnets. The reason is that if you want to change
CIDR for a subnet, you need to free all resources that use this subnet first, like deleting all VMs.</p><p>Changing the IP ranges of subnets in VPC <em>services</em> is easy. I&rsquo;ll change the subnet <em>services</em> IP range to <em>10.3.0.0/24</em>. But to do that, I need to delete the
VMs in the VPC <em>services</em> and recreate peering between VPCs. So, I&rsquo;ll remove VMs from the VPC <em>services</em>_. Then, fixing the subnet range in VPC <em>services</em>,
recreate peering between VPCs. And finally, adding back deleted VMs to the VPC <em>services</em>.</p><p>While I&rsquo;m doing this, I&rsquo;ll revert SSH access to the VMs in all VPCs, but this time, I&rsquo;ll use CIDR ranges to allow access:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_firewall&#34; &#34;services_ssh&#34;</span> {
</span></span><span style=display:flex><span>  name    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;services-ssh&#34;</span>
</span></span><span style=display:flex><span>  network <span style=color:#f92672>=</span> <span style=color:#66d9ef>google_compute_network</span>.<span style=color:#66d9ef>services</span>.<span style=color:#66d9ef>self_link</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  source_ranges <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;10.1.0.0/24&#34;, &#34;10.2.0.0/24&#34;</span>]
</span></span><span style=display:flex><span>  direction     <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INGRESS&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>allow</span> {
</span></span><span style=display:flex><span>    protocol <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;tcp&#34;</span>
</span></span><span style=display:flex><span>    ports    <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;22&#34;</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This limits access to the VMs in the VPC <em>services</em> from the VPC <em>back-office</em> and <em>back-office-private</em> subnets. I&rsquo;ll do the same for the VPC <em>storage</em>.</p><p>You can add one for the VPC <em>storage</em> as well. On top of all this, you&rsquo;ll need to add public SSH keys to the VMs. You can do it per VM or project. I&rsquo;ll do it on
the project level for now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;google_compute_project_metadata&#34; &#34;default&#34;</span> {
</span></span><span style=display:flex><span>  metadata <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    ssh-keys <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>&lt;&lt;</span><span style=color:#66d9ef>EOF</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>user</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#66d9ef>ssh</span><span style=color:#960050;background-color:#1e0010>-</span><span style=color:#66d9ef>rsa</span> <span style=color:#66d9ef>public_key_goes_here</span> <span style=color:#66d9ef>user</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>EOF</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When adding SSH public keys to the project level, you are allowing SSH access to all VMs in the project. For now, this is good enough. To generate SSH keys, you can use
the command <code>ssh-keygen</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ssh-keygen -f private-key -C rnemet -b <span style=color:#ae81ff>2048</span>
</span></span><span style=display:flex><span>Generating public/private rsa key pair.
</span></span><span style=display:flex><span>Enter passphrase <span style=color:#f92672>(</span>empty <span style=color:#66d9ef>for</span> no passphrase<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>Enter same passphrase again:
</span></span><span style=display:flex><span>Your identification has been saved in private-key
</span></span><span style=display:flex><span>Your public key has been saved in private-key.pub
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>The code above will generate two files: <em>private-key</em> and <em>private-key.pub</em>. The file <em>private-key</em> is the private key, and the file <em>private-key.pub</em> is the public key. Now, you
can use the public key to add it to the project metadata. You can also use the private key to connect to the VMs. That means you must keep the private key safe and be on machines you use to
connect to the VMs. After adding the public key to the project metadata, you can connect to the VMs in the VPC <em>services</em> and <em>storages</em> from VPC <em>back-office</em> VMs. All you need when connecting to
the VMs is the private key on bastion VMs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcloud compute scp ./private-key rnemet@back-office-vm1:.ssh/private-key --zone<span style=color:#f92672>=</span>us-central1-c
</span></span><span style=display:flex><span>External IP address was not found; defaulting to using IAP tunneling.
</span></span><span style=display:flex><span>WARNING:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To increase the performance of the tunnel, consider installing NumPy. For instructions,
</span></span><span style=display:flex><span>please see https://cloud.google.com/iap/docs/using-tcp-forwarding#increasing_the_tcp_upload_bandwidth
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>private-key
</span></span></code></pre></div><p>When connecting to the VMs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ssh rnemet@10.120.0.3 -i .ssh/private-key
</span></span></code></pre></div><p>With this setup, I can connect to the VMs in the VPC <em>services</em> and <em>storages</em> from the VM in the VPC <em>back-office</em>. Direct access to other VMs is not possible because
of IAP and firewall rules.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>So far, I have created VPCs, subnets, and VMs. I have also created firewall rules to allow SSH access to the VMs from one VM inside my networks. I have also created
VPC peering between VPCs. Also, I started to share resources between Terraform state files. However, my TF project is growing and needs a better structure. I
need to invest some time to improve it. But at the same time, I would like to put some services that are reachable from the outside.</p><p>What do you think? What would you do next? Let me know&mldr;</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://cloud.google.com/firewall/docs/firewalls>GCP Firewall</a></li><li><a href=https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_firewall>GCP TF firewall</a></li><li><a href=https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance>GCP TF instances</a></li><li><a href=https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes>GCP scopes</a></li><li><a href=https://cloud.google.com/vpc/docs/vpc-peering>GCP VPC peering</a></li></ul><div class=subscribe><iframe src=https://rnemet.substack.com/embed width=480 height=320 style="border:1px solid #eee;background:#fff;margin:auto;display:block" frameborder=0 scrolling=no></iframe></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://rnemet.dev/tags/gcp/>Gcp</a></li><li><a href=https://rnemet.dev/tags/terraform/>Terraform</a></li><li><a href=https://rnemet.dev/tags/cloud/>Cloud</a></li><li><a href=https://rnemet.dev/tags/networking/>Networking</a></li><li><a href=https://rnemet.dev/tags/vpc/>Vpc</a></li><li><a href=https://rnemet.dev/tags/firewall/>Firewall</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on x" href="https://x.com/intent/tweet/?text=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202&amp;url=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f&amp;hashtags=gcp%2cterraform%2ccloud%2cnetworking%2cvpc%2cfirewall"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f&amp;title=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202&amp;summary=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202&amp;source=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f&title=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on whatsapp" href="https://api.whatsapp.com/send?text=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202%20-%20https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on telegram" href="https://telegram.me/share/url?text=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202&amp;url=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exploring GCP With Terraform: VPC Firewall Rules, part 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Exploring%20GCP%20With%20Terraform%3a%20VPC%20Firewall%20Rules%2c%20part%202&u=https%3a%2f%2frnemet.dev%2fposts%2fgcp%2fgcp_tf_vpc_firewall_2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://rnemet.dev/>DevCube</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>